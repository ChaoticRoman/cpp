<details open><summary>Info</summary><p>

* **Did you know that concept can be passed via lambda expression?**

  * http://eel.is/c++draft/#concepts

</p></details><details open><summary>Example</summary><p>

```cpp
static_assert([]<class T>{ return std::integral<T>; }.operator()<int>());

struct f { auto foo() -> void; };
static_assert([](auto t){ return requires { t.foo(); }; }(f{}));
```

> https://godbolt.org/z/3KbevGYK3

</p></details><details open><summary>Puzzle</summary><p>

* **Can you implement concept `foobale` which is satisfied if its parameters satisfies given concepts?**

```cpp
template<class T, auto... Ts>
concept fooable; // TODO

struct bar  { };
static_assert(not fooable<bar>);

struct foo1 { void foo(int); };
static_assert(fooable<foo1, []<class T> { return std::integral<T>; }>);

struct foo2 { void foo(int, short); };
static_assert(fooable<foo2, []<class T> { return std::integral<T>; },
                            []<class T> { return std::same_as<short, T>; }>);
```

> https://godbolt.org/z/ja439rq4o

</p></details><details><summary>Solutions</summary><p>

```cpp
template <class T, auto... ConceptCheckers>
concept fooable = requires(T t) { &T::foo; };
```

> https://godbolt.org/z/KrWrvze85

```cpp
namespace detail {

template <typename...>
struct type_list {};

template <auto...>
struct value_list {};

template <typename T>
concept has_foo = requires(T t) { &T::foo; };

template <typename>
struct foo_function_traits;

template <typename TBase, typename TReturn, typename... TArgs>
struct foo_function_traits<TReturn (TBase::*)(TArgs...)> {
    using arg_types = type_list<TArgs...>;
};

template <typename... TArgs, auto... ConceptCheckers>
[[nodiscard]] consteval auto check_foo_args(type_list<TArgs...>,
                                            value_list<ConceptCheckers...>) {
    if constexpr (sizeof...(TArgs) != sizeof...(ConceptCheckers)) {
        return false;
    } else {
        return (... and ConceptCheckers.template operator()<TArgs>());
    }
}

}  // namespace detail

template <class T, auto... ConceptCheckers>
concept fooable =
    detail::has_foo<T> and
    detail::check_foo_args(
        typename detail::foo_function_traits<decltype(&T::foo)>::arg_types{},
        detail::value_list<ConceptCheckers...>{});
```

> https://godbolt.org/z/ac6M6vKsv

```cpp
template <auto Constraint>
struct ArgConstraint {
    template <typename T>
        requires (Constraint.template operator()<T>())
    operator T();
};

template<class T, auto... Ts>
concept fooable = requires (T x) { x.foo(ArgConstraint<Ts>{}...); }
```

> https://godbolt.org/z/3e6rPGT4f
 
```cpp
template<typename T, typename R, typename ... Args>
consteval auto get_arguments(R(T::*)(Args...))
{
    return std::tuple<Args...>();
}

template <class ArgumentTuple, class FunctionTuple>
consteval decltype(auto) for_each(ArgumentTuple && tuple, FunctionTuple && f)
{
    if constexpr (std::tuple_size_v<ArgumentTuple> != std::tuple_size_v<FunctionTuple>)
        return false;
    
    return [] <std::size_t... I>
        (ArgumentTuple && tuple, FunctionTuple&& f, std::index_sequence<I...>)
        {
            return (std::get<I>(f).template operator()<std::remove_reference_t<decltype(std::get<I>(tuple))>>() && ...);
        }
        (std::forward<ArgumentTuple>(tuple), std::forward<FunctionTuple>(f),
        std::make_index_sequence<std::tuple_size_v<std::remove_reference_t<ArgumentTuple>>>{});
}

template<class T, auto... Ts>
concept fooable = for_each(get_arguments(&T::foo), std::tuple(Ts...));
```
> https://godbolt.org/z/YKs9zGKqz
