<details open><summary>Info</summary><p>

* **Did you know that C++23 extended floating-point types?**

  * https://wg21.link/P1467R9

</p></details><details open><summary>Example</summary><p>

```cpp
#include <stdfloat>

int main() {
    std::float16_t   f16 = .42f16;
    std::bfloat16_t bf16 = .42bf16;
    std::float32_t   f32 = .42f32;
    std::float64_t   f64 = .42f64;
    std::float128_t f128 = .42f128;
}
```

> https://godbolt.org/z/qrE4v1eno

</p></details><details open><summary>Puzzle</summary><p>

* **Can you implement `min_max` which returns a tuple with min and max element based on given predicate?**

```cpp
int main() {
    static_assert(
        std::tuple{sizeof(.1f16), sizeof(.1f64)} == min_max<[]<class T> { return sizeof(T); }>(
            std::tuple{.1f16, .1f64})
    );

    static_assert(
        std::tuple{sizeof(.1f16), sizeof(.1f128)} == min_max<[]<class T> { return sizeof(T); }>(
            std::tuple{.1f16, .1f32, .1f64, .1f128})
    );

    static_assert(
        std::tuple{sizeof(.1f32), sizeof(.1f128)} == min_max<[]<class T> { return sizeof(T); }>(
            std::tuple{.1f128, .1f32, .1f32, .1f64})
    );
}
```

> https://godbolt.org/z/59z431vWc

</p></details><details><summary>Solutions</summary><p>

 ```cpp
#include <array>
template <auto Func, typename... Ts>
constexpr auto min_max(std::tuple<Ts...>&& tuple)
    -> std::tuple<size_t, size_t> {
    using tuple_t = typename std::remove_cvref_t<decltype(tuple)>;
    std::array<size_t, std::tuple_size_v<tuple_t>> buffer = {};
    []<size_t... Is>(auto&& tuple, auto& out,
                     std::index_sequence<Is...> indicies) {
        (static_cast<void>(
             out[Is] =
                 Func.template operator()<std::tuple_element_t<Is, tuple_t>>()),
         ...);
    }(std::forward<decltype(tuple)>(tuple), buffer,
      std::make_index_sequence<std::tuple_size_v<tuple_t>>{});
    const auto [min, max] = std::ranges::minmax(buffer);
    return {min, max};
}
 ```
 > https://godbolt.org/z/E36Eh4fqz
 
</p></details>
