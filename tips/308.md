<details open><summary>Info</summary><p>

* **Did you know that the layout of struct fields will affect its size/alignment?**

  * https://eel.is/c++draft/basic.types.general#:class,standard-layout

</p></details><details open><summary>Example</summary><p>

```cpp
struct unpacked {
  char a;  // size: 1b => size: 4b
  int  b;  // size: 4b => size: 4b
  char c;  // size: 1b => size: 4b
           //             ---------
           //             size: 12b
};

struct packed {
  char a;  // size: 1b => size: 4b
  char b;  // size: 1b => size: 4b
  int  c;  // size: 4b => size: 8b
           //             --------
           //             size: 8b
};

static_assert(12 == sizeof(unpacked));
static_assert(8 == sizeof(packed));

```

> https://godbolt.org/z/q794afz8E

</p></details><details open><summary>Puzzle</summary><p>

* **Can you implement `is_packed_layout` trait which for given type T will return
  { true: if the sizeof...(T.fields) == sizeof(T) or alignments of T.fields are sorted, false : otherwise }?**

```cpp
template<class T> constexpr auto is_packed_layout_v;

struct unpacked {
  char a;  // size: 1b => size: 4b
  int  b;  // size: 4b => size: 4b
  char c;  // size: 1b => size: 4b
           //             ---------
           //             size: 12b
};

struct unpacked1 {
  int  b;  // size: 4b => size: 4b
  char a;  // size: 1b => size: 8b
  int c;   // size: 4b => size: 12b
           //             ---------
           //             size: 12b
};

struct packed {
  char a;  // size: 1b => size: 4b
  char b;  // size: 1b => size: 4b
  int  c;  // size: 4b => size: 8b
           //             --------
           //             size: 8b
};

struct packed1 {
  int a;   // size: 4b => size: 4b
           //             --------
           //             size: 4b
};

struct packed2 {
  int  c;  // size: 4b => size: 4b
  char a;  // size: 1b => size: 8b
  char b;  // size: 1b => size: 8b
           //             --------
           //             size: 8b
};

struct packed3 {
  int x;   // size: 4b => size: 4b
  char a;  // size: 1b => size: 8b
  char b;  // size: 1b => size: 8b
  char c;  // size: 1b => size: 8b
  char d;  // size: 1b => size: 8b
  int y;   // size: 4b => size: 12b
           //             ---------
           //             size: 12b
};

struct packed4 {
  using a3_t = std::array<char, 3>;
  short x; // size: 2b => size: 2b
  short y; // size: 2b => size: 4b
  a3_t z;  // size: 3b => size: 8b
           //             --------
           //             size: 8b
};

struct packed5 {
  short x; // size: 2b => size: 2b
  short y; // size: 2b => size: 4b
  short z; // size: 2b => size: 6b
           //             --------
           //             size: 6b
};

struct empty {
           // size: 1b => size: 1b
           //             --------
           //             size: 1b
};

static_assert(12 == sizeof(unpacked));
static_assert(not is_packed_layout_v<unpacked>);

static_assert(12 == sizeof(unpacked1));
static_assert(not is_packed_layout_v<unpacked1>);

static_assert(8 == sizeof(packed));
static_assert(is_packed_layout_v<packed>);

static_assert(4 == sizeof(packed1));
static_assert(is_packed_layout_v<packed1>);

static_assert(8 == sizeof(packed2));
static_assert(is_packed_layout_v<packed2>);

static_assert(12 == sizeof(packed3));
static_assert(is_packed_layout_v<packed3>);

static_assert(8 == sizeof(packed4));
static_assert(is_packed_layout_v<packed4>);

static_assert(6 == sizeof(packed5));
static_assert(is_packed_layout_v<packed5>);

static_assert(1 == sizeof(empty));
static_assert(is_packed_layout_v<empty>);
```

> https://godbolt.org/z/x17PMbEWe

</p></details><details><summary>Solutions</summary><p>

```cpp
#include <algorithm>
#include <array>
#include <type_traits>

template <class T, class... TArgs> decltype(void(T{std::declval<TArgs>()...}), std::true_type{}) test_is_braces_constructible(int);
template <class, class...> std::false_type test_is_braces_constructible(...);
template <class T, class... TArgs> using is_braces_constructible = decltype(test_is_braces_constructible<T, TArgs...>(0));

struct any_type {
  template<class T> constexpr operator T();
};

template<class T> constexpr bool size_of_fields_equals_size_of_struct() noexcept {
  constexpr T object{};
  if constexpr(is_braces_constructible<T, any_type, any_type, any_type, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2, m3, m4, m5] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2) + sizeof(m3) + sizeof(m4) + sizeof(m5);
  } else if constexpr(is_braces_constructible<T, any_type, any_type, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2, m3, m4] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2) + sizeof(m3) + sizeof(m4);
  } else if constexpr(is_braces_constructible<T, any_type, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2, m3] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2) + sizeof(m3);
  } else if constexpr(is_braces_constructible<T, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1) + sizeof(m2);
  } else if constexpr(is_braces_constructible<T, any_type, any_type>{}) {
      auto&& [m0, m1] = object;
      return sizeof(T) == sizeof(m0) + sizeof(m1);
  } else if constexpr(is_braces_constructible<T, any_type>{}) {
      auto&& [m0] = object;
      return sizeof(T) == sizeof(m0);
  } else {
      return true;
  }
}

template<class T> constexpr bool alignments_sorted() noexcept {
  constexpr T object{};
  if constexpr(is_braces_constructible<T, any_type, any_type, any_type, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2, m3, m4, m5] = object;
      std::array<int, 6> sizes{sizeof(m0), sizeof(m1), sizeof(m2), sizeof(m3), sizeof(m4), sizeof(m5)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible<T, any_type, any_type, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2, m3, m4] = object;
      std::array<int, 5> sizes{sizeof(m0), sizeof(m1), sizeof(m2), sizeof(m3), sizeof(m4)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible<T, any_type, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2, m3] = object;
      std::array<int, 4> sizes{sizeof(m0), sizeof(m1), sizeof(m2), sizeof(m3)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible<T, any_type, any_type, any_type>{}) {
      auto&& [m0, m1, m2] = object;
      std::array<int, 3> sizes{sizeof(m0), sizeof(m1), sizeof(m2)};
      return std::is_sorted(sizes.cbegin(), sizes.cend(), std::less{}) || std::is_sorted(sizes.cbegin(), sizes.cend(), std::greater{});
  } else if constexpr(is_braces_constructible<T, any_type, any_type>{}) {
      return true;
  } else if constexpr(is_braces_constructible<T, any_type>{}) {
      return true;
  } else {
      return true;
  }
}

template<class T> constexpr auto is_packed_layout_v = size_of_fields_equals_size_of_struct<T>() || alignments_sorted<T>(); 

struct unpacked {
  char a;  // size: 1b => size: 4b
  int  b;  // size: 4b => size: 4b
  char c;  // size: 1b => size: 4b
           //             ---------
           //             size: 12b
};

struct unpacked1 {
  int  b;  // size: 4b => size: 4b
  char a;  // size: 1b => size: 8b
  int c;   // size: 4b => size: 12b
           //             ---------
           //             size: 12b
};

struct packed {
  char a;  // size: 1b => size: 4b
  char b;  // size: 1b => size: 4b
  int  c;  // size: 4b => size: 8b
           //             --------
           //             size: 8b
};

struct packed1 {
  int a;   // size: 4b => size: 4b
           //             --------
           //             size: 4b  
};

struct packed2 {
  int  c;  // size: 4b => size: 4b
  char a;  // size: 1b => size: 8b
  char b;  // size: 1b => size: 8b
           //             --------
           //             size: 8b  
};

struct packed3 {
  int x;   // size: 4b => size: 4b
  char a;  // size: 1b => size: 8b
  char b;  // size: 1b => size: 8b
  char c;  // size: 1b => size: 8b
  char d;  // size: 1b => size: 8b
  int y;   // size: 4b => size: 12b
           //             ---------
           //             size: 12b  
};

struct packed4 {
  using a3_t = std::array<char, 3>;
  short x; // size: 2b => size: 2b
  short y; // size: 2b => size: 4b
  a3_t z;  // size: 3b => size: 8b
           //             --------
           //             size: 8b  
};

struct packed5 {
  short x; // size: 2b => size: 2b
  short y; // size: 2b => size: 4b
  short z; // size: 2b => size: 6b
           //             --------
           //             size: 6b  
};

struct empty {
           // size: 1b => size: 1b
           //             --------
           //             size: 1b           
};

static_assert(12 == sizeof(unpacked));
static_assert(not is_packed_layout_v<unpacked>);

static_assert(12 == sizeof(unpacked1));
static_assert(not is_packed_layout_v<unpacked1>);

static_assert(8 == sizeof(packed));
static_assert(is_packed_layout_v<packed>);

static_assert(4 == sizeof(packed1));
static_assert(is_packed_layout_v<packed1>);

static_assert(8 == sizeof(packed2));
static_assert(is_packed_layout_v<packed2>);

static_assert(12 == sizeof(packed3));
static_assert(is_packed_layout_v<packed3>);

static_assert(8 == sizeof(packed4));
static_assert(is_packed_layout_v<packed4>);

static_assert(6 == sizeof(packed5));
static_assert(is_packed_layout_v<packed5>);

static_assert(1 == sizeof(empty));
static_assert(is_packed_layout_v<empty>);
```
> https://godbolt.org/z/46orYesoW
