<details open><summary>Info</summary><p>

* **Did you know that with C++20 you can pass concepts?**

  * Although `template<template<class...> concept C>` is not valid
  * https://eel.is/c++draft/#concepts

</p></details><details open><summary>Example</summary><p>

```cpp
template<class T>
concept foo_like = requires(T t) { t.foo; };

template<auto Concept>
struct foo {
  auto fn(auto f) {
    static_assert(requires { Concept(f); });
  }
};

int main() {
  foo<[](foo_like auto){}> f{};

  struct { int foo{}; } foo;
  struct { } bar;

  f.fn(foo); // ok
  f.fn(bar); // error: contrain not satisfied
}
```

> https://godbolt.org/z/dE9nWdETs

</p></details><details open><summary>Puzzle</summary><p>

> **Can you implement simple dependency injection framework based on concepts?**

```cpp
template<class T>
constexpr auto create(auto&& injector); // TODO

template<class T> concept foo_like = requires(T t) { t.f; };
template<class T> concept bar_like = requires(T t) { t.b; };

auto foo_like_v = [](foo_like auto){};
auto bar_like_v = [](bar_like auto){};

struct foo { int f{}; };
struct bar { int b{}; };

struct app {
  static constexpr auto ctor_traits = injector{foo_like_v, bar_like_v}; // reflection
  app(foo_like auto f, bar_like auto b) { }
};

int main() {
  auto i = injector{
    bind<bar_like_v, bar>{},
    bind<foo_like_v, foo>{},
  };

  auto a = create<app>(i);
  static_assert(sizeof(a));
}
```

> https://godbolt.org/z/8T9P174M5

</p></details><details><summary>Solutions</summary><p>
